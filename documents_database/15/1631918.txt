like lambda calculus it supports a uniform treatment of function evaluation also it allows functions to be passed as arguments and returned as results in addition pattern calculus supports uniform access to the internal structure of arguments be they pairs or lists or trees also it allows patterns to be passed as arguments and returned as results uniform access is illustrated by a pattern matching function size that computes the size of an arbitrary data structure in the notation of the programming language bondi it is given by the recursive function the second or default case x 1 matches the pattern x against the argument and returns 1 this case is used only if the matching failed in the first case the first or special case matches against any compound such as a non empty list or pair matching binds x to the left component and y to the right component then the body of the case adds the sizes of these components together similar techniques yield generic queries for searching and updating combining recursion and decomposition in this way yields path polymorphism the ability to pass patterns as parameters pattern polymorphism is illustrated by defining a generic eliminator suppose