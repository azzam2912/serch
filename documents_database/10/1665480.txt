gradle uses a directed acyclic graph dag to determine the order in which tasks can be run gradle was designed for multi project builds which can grow to be quite large it supports incremental builds by intelligently determining which parts of the build tree are up to date any task dependent only on those parts does not need to be re executed as of 2016 the initial plugins were primarily focused on java groovy and scala development and deployment but more languages and project workflows are on the roadmap consider the case where the maven directory structure is used for java sources and resources these directories are src main java src main resources src test java and src test resources build gradle apply plugin java running gradle build will result in gradle build build successful the java plugin emulates many of the expected maven lifecycles as tasks in the directed acyclic graph of dependencies for the inputs and outputs of each task for this simple case the build task depends upon the outputs of the check and assemble tasks likewise check depends upon test and assemble depends upon jar for projects that do not follow the maven conventions gradle allows