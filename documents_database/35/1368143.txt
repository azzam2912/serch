it has to cooperate with local garbage collectors in each process in order to keep global counts or to globally trace accessibility of data in general remote processors do not have to know about internal counting or tracing in a given process and the relevant information is stored in interfaces associated with each process dgc is complex and can be costly and slow in freeing memory as a cheap way of avoiding dgc algorithms one can rely on a time lease set or configured on the remote object it is the stub s task to periodically renew the lease on the remote object if the lease has expired the server process the process owning the remote object can safely assume that either the client is no longer interested in the object or that a network partition or crash obstructed lease renewal in which case it is hard luck for the client if it is in fact still interested hence if there is only a single reference to the remote object on the server representing a remote reference from that client that reference can be dropped which will mean that the local garbage collector on the server will garbage collect the