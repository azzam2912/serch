in software engineering two components are connascent if a change in one would require the other to be modified in order to maintain the overall correctness of the system in addition to allowing categorization of dependency relationships connascence also provides a system for comparing different types of dependency such comparisons between potential designs can often hint at ways to improve the quality of the software a form of connascence is considered to be stronger if it is more likely to require compensating changes in connascent elements the stronger the form of connascence the more difficult and costly it is to change the elements in the relationship the acceptability of connascence is related to the degree of its occurrence connascence might be acceptable in limited degree but unacceptable in large degree for example a function or method that takes two arguments is generally considered acceptable however it is usually unacceptable for functions or methods to take ten arguments elements with a high degree of connascence incur greater difficulty and cost of change than elements that have a lower degree locality matters when analyzing connascence stronger forms of connascence are acceptable if the elements involved are closely related for example many languages