so the design undergoes a kind of translation to scaled down abstract version the set of variables are partitioned into visible and invisible depending on their change of values the real state space is summarized into a smaller set of the visible ones the real and the abstract state spaces are galois connected this means that if we take an element from the abstract space concretize it and abstract the concretized version the result will be equal to the original on the other hand if you pick an element from the real space abstract it and concretize the abstract version the final result will be a super set of the original that is formula 1 formula 2 abstract abstract formula 2 formula 1 real formula 5 real a problem with abstraction model checking is that although the abstraction simulates the real when the abstraction does not satisfy a property it does not mean that this property actually fails in the real model counter examples are checked against the real state space because we obtain spurious counter examples so a part of the abstraction refinement loop is spurious examples are mostly generated because dead end states and bad states are abstracted