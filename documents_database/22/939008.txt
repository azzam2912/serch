the difference is that aot transforms the bytecode of an extant virtual machine vm into machine code some programming languages with a managed code runtime that can be compiled to an intermediate representation use just in time jit compiling this briefly compiles intermediate code into machine code for a native run while the intermediate code is executing which may slow an application s performance ahead of time compiling eliminates the need for this step by occurring before execution rather than during execution ahead of time compiling for dynamically typed languages to native machine code or other static vm bytecode is possible in a limited number of cases only for example the high performance erlang project hipe aot compiler for the language erlang can do this because of advanced static type reconstruction techniques and type speculations in most situations with fully aot compiled programs and libraries it is possible to drop a useful fraction of a runtime environment thus saving disk space memory battery life and startup times no jit warmup phase etc because of this it can be useful in embedded or mobile devices aot compilers can perform complex and advanced code optimizations which in most cases of jiting will