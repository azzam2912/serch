the join calculus was developed to provide a formal basis for the design of distributed programming languages and therefore intentionally avoids communications constructs found in other process calculi such as rendezvous communications which are difficult to implement in a distributed setting despite this limitation the join calculus is as expressive as the full calculus encodings of the calculus in the join calculus and vice versa have been demonstrated the join calculus is a member of the calculus family of process calculi and can be considered at its core an asynchronous calculus with several strong restrictions however as a language for programming the join calculus offers at least one convenience over the calculus namely the use of multi way join patterns the ability to match against messages from multiple channels simultaneously the join calculus programming language is a new language based on the join calculus process calculus it is implemented as an interpreter written in ocaml and supports statically typed distributed programming transparent remote communication agent based mobility and some failure detection many implementations of the join calculus were made as extensions of existing programming languages these implementations do not change the underlying programming language but introduce join calculus operations through