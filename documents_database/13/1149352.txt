in practice it resembles long division of the binary message string with a fixed number of zeroes appended by the generator polynomial string except that exclusive or operations replace subtractions division of this type is efficiently realised in hardware by a modified shift register and in software by a series of equivalent algorithms starting with simple code close to the mathematics and becoming faster and arguably more obfuscated through byte wise parallelism and space time tradeoffs various crc standards extend the polynomial division algorithm by specifying an initial shift register value a final exclusive or step and most critically a bit ordering endianness as a result the code seen in practice deviates confusingly from pure division and the register may shift left or right as an example of implementing polynomial division in hardware suppose that we are trying to compute an 8 bit crc of an 8 bit message made of the ascii character w which is binary 01010111 decimal 87 or hexadecimal 57 for illustration we will use the crc 8 atm hec polynomial formula 1 writing the first bit transmitted the coefficient of the highest power of formula 2 on the left this corresponds to the 9 bit