the complementary functions codice 1 and codice 2 provide this functionality a typical use of codice 1 codice 2 is implementation of an exception mechanism that exploits the ability of codice 2 to reestablish program or thread state even across multiple levels of function calls a less common use of codice 1 is to create syntax similar to coroutines codice 1 saves the current environment the program state at some point of program execution into a platform specific data structure codice 8 that can be used at some later point of program execution by codice 2 to restore the program state to that saved by codice 1 into codice 8 this process can be imagined to be a jump back to the point of program execution where codice 1 saved the environment the apparent return value from codice 1 indicates whether control reached that point normally zero or from a call to codice 2 nonzero this leads to a common idiom posix 1 does not specify whether codice 1 and codice 2 save and restore the current set of blocked signals if a program employs signal handling it should use posix s codice 17 codice 18 the c99 rationale describes