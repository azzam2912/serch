typically a recursive mutex tracks the number of times it has been locked and requires equally many unlock operations to be performed before other threads may lock it recursive mutexes solve the problem of non reentrancy with regular mutexes if a function that takes a lock and executes a callback is itself called by the callback deadlock ensues in pseudocode that is the following situation given these definitions the function call will cause the following sequence of events replacing the mutex with a recursive one solves the problem because the final will succeed without blocking w richard stevens notes that recursive locks are tricky to use correctly and recommends their use for adapting single threaded code without changing apis but only when no other solution is possible the java language s native synchronization mechanism monitor uses recursive locks syntactically a lock is a block of code with the synchronized keyword preceding it and any object reference in parentheses that will be used as the mutex inside the synchronized block the given object can be used as a condition variable by doing a wait notify or notifyall on it thus all objects are both recursive mutexes and condition variables software emulation