however as suggested in the ibm developerworks journal understanding bytecode and what bytecode is likely to be generated by a java compiler helps the java programmer in the same way that knowledge of assembly helps the c or c programmer the jvm is both a stack machine and a register machine each frame for a method call has an operand stack and an array of local variables the operand stack is used for operands to computations and for receiving the return value of a called method while local variables serve the same purpose as registers and are also used to pass method arguments the maximum size of the operand stack and local variable array computed by the compiler is part of the attributes of each method each can be independently sized from 0 to 65535 values where each value is 32 bits and types which are 64 bits take up two consecutive local variables which need not be 64 bit aligned in the local variables array or one value in the operand stack but are counted as two units in the depth of the stack each bytecode is composed of one byte that represents the opcode along with zero or